---
title: "Plumber package"
draft: true
author: Shirin Glander
date: '2018-01-10'
categories: ["R"]
tags: ["Fairness", "Machine Learning"]
thumbnailImagePosition: left
thumbnailImage: https://shiring.github.io/netlify_images/
metaAlignment: center
coverMeta: out
slug: plumber
---



<p>The <a href="www.rplumber.io">plumber</a> package for R makes it easy to expose existing R code as a webservice via an API (Trestle Technology, LLC 2017).</p>
<p>You take an existing R script and make it accessible with <code>plumber</code> by simply adding a few lines of comments. If you have worked with Roxygen before, e.g. when building a package, you will already be familiar with the core concepts. If not, here are the most important things to know:</p>
<ul>
<li>you can define every input parameter that will go into your function</li>
<li>you define the output or endpoint</li>
</ul>
<div id="what-are-apis-and-webservices" class="section level2">
<h2>What are APIs and webservices?</h2>
<p>With <code>plumber</code>, we can build so called <strong>HTTP APIs</strong>. HTTP stands for Hypertext Transfer Protocol and is used to transmit information on the web; API stands for Application Programming Interface and governs the connection between some software and underlying applications. Software can then communicate via HTTP APIs.</p>
</div>
<div id="how-to-convert-your-r-script-into-an-api-with-plumber" class="section level2">
<h2>How to convert your R script into an API with plumber</h2>
<p>Let’s say we have trained a machine learning model as in <a href="https://shirinsplayground.netlify.com/2017/12/lime_sketchnotes/">this post about LIME</a>. I loaded a data set on chronic kidney disease, did some preprocessing, split it into training and test data and trained a random forest model with <code>caret</code>. We could now call predictions for one test case with the following code:</p>
<pre class="r"><code># load test data
load(&quot;../../data/test_data.RData&quot;)

# load model
load(&quot;../../data/model_rf.RData&quot;)</code></pre>
<pre><code>## Warning in as.POSIXlt.POSIXct(Sys.time()): unknown timezone &#39;zone/tz/2017c.
## 1.0/zoneinfo/Europe/Berlin&#39;</code></pre>
<pre class="r"><code># take first test case for prediction
test &lt;- test_data[1, ]

# predict test case using model
pred &lt;- predict(model_rf, test, type = &quot;prob&quot;)</code></pre>
<p>I am wrapping the <code>predict()</code> function in a new custom function <code>calculate prediction()</code> because I might want to be able to quickly add additional preprocessing steps later without having to change too much code. With the function as it is right now this is not technically necessary.</p>
<pre class="r"><code>library(plumber)</code></pre>
<p>In order to convert this very simple script into an API, we need to define the endpoint(s). Endpoints will return an output, in our case it will return the prediction probabilites from the <code>predict()</code> function. Here, we want to have the predictions returned, so we annotate the <code>predict()</code> function with <code># @get</code>. This endpoint in the API we will give a custom name, so that we can call it later; here we call it <code>predict</code> and therefore write <code>#' @get /predict</code>.</p>
<blockquote>
<p>According to the design of the HTTP specification, GET (along with HEAD) requests are used only to read data and not change it. Therefore, when used this way, they are considered safe. That is, they can be called without risk of data modification or corruption—calling it once has the same effect as calling it 10 times, or none at all. Additionally, GET (and HEAD) is idempotent, which means that making multiple identical requests ends up having the same result as a single request. <a href="http://www.restapitutorial.com/lessons/httpmethods.html" class="uri">http://www.restapitutorial.com/lessons/httpmethods.html</a></p>
</blockquote>
<pre class="r"><code># predict test case using model
#&#39; @get /predict
calculate_prediction &lt;- function(test) {
  predict(model_rf, test, type = &quot;prob&quot;)
}</code></pre>
<p>We need to save the entire script as a <em>.R</em> file like so:</p>
<pre class="r"><code># plumber.R

# load model
load(&quot;../../data/model_rf.RData&quot;)

# predict test case using model
#&#39; @get /predict
#&#39; #&#39; @html
calculate_prediction &lt;- function(test) {
  predict(model_rf, test, type = &quot;prob&quot;)
}</code></pre>
<p>However, we still need to define the input, in our case the test data. When we look at the model object, we see that it expects the following parameters:</p>
<pre class="r"><code>model_rf$finalModel$xNames</code></pre>
<pre><code>##  [1] &quot;age&quot;            &quot;bp&quot;             &quot;sg_1.005&quot;       &quot;sg_1.010&quot;      
##  [5] &quot;sg_1.015&quot;       &quot;sg_1.020&quot;       &quot;sg_1.025&quot;       &quot;al_0&quot;          
##  [9] &quot;al_1&quot;           &quot;al_2&quot;           &quot;al_3&quot;           &quot;al_4&quot;          
## [13] &quot;al_5&quot;           &quot;su_0&quot;           &quot;su_1&quot;           &quot;su_2&quot;          
## [17] &quot;su_3&quot;           &quot;su_4&quot;           &quot;su_5&quot;           &quot;rbc_normal&quot;    
## [21] &quot;rbc_abnormal&quot;   &quot;pc_normal&quot;      &quot;pc_abnormal&quot;    &quot;pcc_present&quot;   
## [25] &quot;pcc_notpresent&quot; &quot;ba_present&quot;     &quot;ba_notpresent&quot;  &quot;bgr&quot;           
## [29] &quot;bu&quot;             &quot;sc&quot;             &quot;sod&quot;            &quot;pot&quot;           
## [33] &quot;hemo&quot;           &quot;pcv&quot;            &quot;wbcc&quot;           &quot;rbcc&quot;          
## [37] &quot;htn_yes&quot;        &quot;htn_no&quot;         &quot;dm_yes&quot;         &quot;dm_no&quot;         
## [41] &quot;cad_yes&quot;        &quot;cad_no&quot;         &quot;appet_good&quot;     &quot;appet_poor&quot;    
## [45] &quot;pe_yes&quot;         &quot;pe_no&quot;          &quot;ane_yes&quot;        &quot;ane_no&quot;</code></pre>
<p>In order for <code>plumber</code> to work with our input, it needs to be part of the HTTP request, which can then be routed to our R function.</p>
<p>The <a href="https://www.rplumber.io/docs/quickstart.html#specifying-the-inputs">plumber documentation</a> describes how to use query strings as inputs. But for our case, manually writing query strings is not practical because we have so many parameters. Of course, there are programs that let us generate query strings but the easiest way I found to format the input from a line of data is to use JSON.</p>
<p>The <code>toJSON()</code> function from the <code>rjson</code> package converts out input line to JSON format:</p>
<pre class="r"><code>library(rjson)
test_case_json &lt;- toJSON(test)
cat(test_case_json)</code></pre>
<pre><code>## {&quot;class&quot;:&quot;ckd&quot;,&quot;age&quot;:0.511111111111111,&quot;bp&quot;:0.111111111111111,&quot;sg_1.005&quot;:1,&quot;sg_1.010&quot;:0,&quot;sg_1.015&quot;:0,&quot;sg_1.020&quot;:0,&quot;sg_1.025&quot;:0,&quot;al_0&quot;:0,&quot;al_1&quot;:0,&quot;al_2&quot;:0,&quot;al_3&quot;:0,&quot;al_4&quot;:1,&quot;al_5&quot;:0,&quot;su_0&quot;:1,&quot;su_1&quot;:0,&quot;su_2&quot;:0,&quot;su_3&quot;:0,&quot;su_4&quot;:0,&quot;su_5&quot;:0,&quot;rbc_normal&quot;:1,&quot;rbc_abnormal&quot;:0,&quot;pc_normal&quot;:0,&quot;pc_abnormal&quot;:1,&quot;pcc_present&quot;:1,&quot;pcc_notpresent&quot;:0,&quot;ba_present&quot;:0,&quot;ba_notpresent&quot;:1,&quot;bgr&quot;:0.193877551020408,&quot;bu&quot;:0.139386189258312,&quot;sc&quot;:0.0447368421052632,&quot;sod&quot;:0.653374233128834,&quot;pot&quot;:0,&quot;hemo&quot;:0.455056179775281,&quot;pcv&quot;:0.425925925925926,&quot;wbcc&quot;:0.170454545454545,&quot;rbcc&quot;:0.225,&quot;htn_yes&quot;:1,&quot;htn_no&quot;:0,&quot;dm_yes&quot;:0,&quot;dm_no&quot;:1,&quot;cad_yes&quot;:0,&quot;cad_no&quot;:1,&quot;appet_good&quot;:0,&quot;appet_poor&quot;:1,&quot;pe_yes&quot;:1,&quot;pe_no&quot;:0,&quot;ane_yes&quot;:1,&quot;ane_no&quot;:0}</code></pre>
<p>We can now run our script with the <code>plumb()</code> function and open it on port 800. Because we annotated the <code>calculate_prediction()</code> function in our script with <code>#' @get /predict</code> we could access it via *<a href="http://localhost:8000/predict*" class="uri">http://localhost:8000/predict*</a>.</p>
<pre class="r"><code>r &lt;- plumb(&quot;/Users/shiringlander/Documents/Github/shirinsplayground/static/scripts/plumber.R&quot;)
r$run(port=8000)</code></pre>
<p>But we want to put our JSON formatted input into the function as the <code>test</code> parameter. To do this, we can use <em>curl</em> from the command line and feed in the JSON string from above.</p>
<pre><code>curl -H &quot;Content-Type: application/json&quot; -X GET -d &#39;{&quot;test&quot;:[{&quot;class&quot;:&quot;ckd&quot;,&quot;age&quot;:0.511111111111111,&quot;bp&quot;:0.111111111111111,&quot;sg_1.005&quot;:1,&quot;sg_1.010&quot;:0,&quot;sg_1.015&quot;:0,&quot;sg_1.020&quot;:0,&quot;sg_1.025&quot;:0,&quot;al_0&quot;:0,&quot;al_1&quot;:0,&quot;al_2&quot;:0,&quot;al_3&quot;:0,&quot;al_4&quot;:1,&quot;al_5&quot;:0,&quot;su_0&quot;:1,&quot;su_1&quot;:0,&quot;su_2&quot;:0,&quot;su_3&quot;:0,&quot;su_4&quot;:0,&quot;su_5&quot;:0,&quot;rbc_normal&quot;:1,&quot;rbc_abnormal&quot;:0,&quot;pc_normal&quot;:0,&quot;pc_abnormal&quot;:1,&quot;pcc_present&quot;:1,&quot;pcc_notpresent&quot;:0,&quot;ba_present&quot;:0,&quot;ba_notpresent&quot;:1,&quot;bgr&quot;:0.193877551020408,&quot;bu&quot;:0.139386189258312,&quot;sc&quot;:0.0447368421052632,&quot;sod&quot;:0.653374233128834,&quot;pot&quot;:0,&quot;hemo&quot;:0.455056179775281,&quot;pcv&quot;:0.425925925925926,&quot;wbcc&quot;:0.170454545454545,&quot;rbcc&quot;:0.225,&quot;htn_yes&quot;:1,&quot;htn_no&quot;:0,&quot;dm_yes&quot;:0,&quot;dm_no&quot;:1,&quot;cad_yes&quot;:0,&quot;cad_no&quot;:1,&quot;appet_good&quot;:0,&quot;appet_poor&quot;:1,&quot;pe_yes&quot;:1,&quot;pe_no&quot;:0,&quot;ane_yes&quot;:1,&quot;ane_no&quot;:0}]}&#39; &quot;http://localhost:8000/predict&quot;</code></pre>
<p>This will return the following output (also in JSON format):</p>
<p><em>[{“ckd”:0.984,“notckd”:0.016}]</em></p>
</div>
<div id="tweaking-the-output" class="section level2">
<h2>Tweaking the output</h2>
<pre class="r"><code># plumber2.R

# load model
load(&quot;../../data/model_rf.RData&quot;)

# predict test case using model
#&#39; @get /predict
calculate_prediction &lt;- function(test) {
  pred &lt;- predict(model_rf, test)
  cat(&quot;----------------\nTest case predicted to be&quot;, unlist(pred), &quot;\n----------------&quot;)
}</code></pre>
<pre class="r"><code>r2 &lt;- plumb(&quot;/Users/shiringlander/Documents/Github/shirinsplayground/static/scripts/plumber2.R&quot;)
r2$run(port=8000)</code></pre>
<p>With the same <em>curl</em> command from above we now get output to our R console:</p>
<pre><code>----------------
Test case predicted to be 1 
----------------</code></pre>
</div>
<div id="filters" class="section level2">
<h2>Filters</h2>
<pre class="r"><code>r3 &lt;- plumb(&quot;/Users/shiringlander/Documents/Github/shirinsplayground/static/scripts/plumber3.R&quot;)
r3$run(port=8000)</code></pre>
<pre><code>2018-01-12 08:12:41 - GET /predict - curl/7.54.0 @ 127.0.0.1 
----------------
Test case predicted to be 1 
----------------</code></pre>
<hr />
<p><a href="https://www.r-bloggers.com/initiating-development-of-a-chatbot-with-plumber-and-ngrok/" class="uri">https://www.r-bloggers.com/initiating-development-of-a-chatbot-with-plumber-and-ngrok/</a></p>
<hr />
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.4.2 (2017-09-28)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.2
## 
## Matrix products: default
## BLAS: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] de_DE.UTF-8/de_DE.UTF-8/de_DE.UTF-8/C/de_DE.UTF-8/de_DE.UTF-8
## 
## attached base packages:
## [1] methods   stats     graphics  grDevices utils     datasets  base     
## 
## other attached packages:
## [1] rjson_0.2.15  plumber_0.4.4
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.14        lubridate_1.7.1     lattice_0.20-35    
##  [4] tidyr_0.7.2         class_7.3-14        assertthat_0.2.0   
##  [7] rprojroot_1.2       digest_0.6.12       ipred_0.9-6        
## [10] psych_1.7.8         foreach_1.4.3       R6_2.2.2           
## [13] plyr_1.8.4          backports_1.1.1     stats4_3.4.2       
## [16] evaluate_0.10.1     ggplot2_2.2.1       blogdown_0.3       
## [19] rlang_0.1.4         lazyeval_0.2.1      caret_6.0-77       
## [22] kernlab_0.9-25      rpart_4.1-11        Matrix_1.2-12      
## [25] rmarkdown_1.8       splines_3.4.2       CVST_0.2-1         
## [28] ddalpha_1.3.1       gower_0.1.2         stringr_1.2.0      
## [31] foreign_0.8-69      munsell_0.4.3       broom_0.4.3        
## [34] httpuv_1.3.5        compiler_3.4.2      pkgconfig_2.0.1    
## [37] mnormt_1.5-5        dimRed_0.1.0        htmltools_0.3.6    
## [40] nnet_7.3-12         tidyselect_0.2.3    tibble_1.3.4       
## [43] prodlim_1.6.1       DRR_0.0.2           bookdown_0.5       
## [46] codetools_0.2-15    randomForest_4.6-12 RcppRoll_0.2.2     
## [49] crayon_1.3.4        withr_2.1.0         dplyr_0.7.4        
## [52] MASS_7.3-47         recipes_0.1.1       ModelMetrics_1.1.0 
## [55] grid_3.4.2          jsonlite_1.5        nlme_3.1-131       
## [58] gtable_0.2.0        magrittr_1.5        scales_0.5.0       
## [61] stringi_1.1.6       reshape2_1.4.2      bindrcpp_0.2       
## [64] timeDate_3042.101   robustbase_0.92-8   lava_1.5.1         
## [67] iterators_1.0.8     tools_3.4.2         glue_1.2.0         
## [70] DEoptimR_1.0-8      purrr_0.2.4         sfsmisc_1.1-1      
## [73] parallel_3.4.2      survival_2.41-3     yaml_2.1.15        
## [76] colorspace_1.3-2    knitr_1.17          bindr_0.1</code></pre>
</div>
